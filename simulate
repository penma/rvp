#!/usr/bin/env perl
use strict;
use warnings;
use 5.010;

use Data::Dumper;
use Date::Format;
use Date::Parse;
use List::Util qw(min);
use List::MoreUtils qw(firstidx after);

my $d = do("route_data");
my @routes = @{$d->{routes}};
my @physroutes = @{$d->{physroutes}};
my $starttime = str2time("2010-03-22 12:03:00", "CET");

sub trip_details {
	my ($trip) = @_;
	sprintf("((%s) %s %s %s): %s",
		time2str("%H:%M", $trip->{state}->{next_time}, "CET"),
		$trip->{state}->{state},
		$trip->{state}->{station},
		$trip->{state}->{route} ? $trip->{state}->{route}->{line} : "-",
		join(" - ", map { sprintf("(%s) %s %s",
			time2str("%H:%M", $_->{time}, "CET"),
			$_->{event},
			$_->{station}
		) } @{$trip->{events}}),
	);
}

foreach my $physroute (@physroutes) {
	print "\n" . "-" x 80 . "\n\n";
	print "next route: " . join(" - ", @{$physroute}) . "\n";

	# initialize the trips list with one trip, that starts with the
	# virtual passenger (VP) at the start station.

	my @trips = (
		{
			state => {
				station   => $physroute->[0],
				next_time => $starttime,
				route     => undef,
				state     => "wait_arrive_station",
			},
			events => [
				{
					event   => "vp_start",
					station => $physroute->[0],
					time    => $starttime,
				},
			],
		},
	);

	my @completed_trips;

	while (@trips) {
		# next simulation point-in-time: smallest NSC
		my $nsc = min map { $_->{state}->{next_time} } @trips;
		print STDERR "\n\nsimulation time: " . time2str("%H:%M", $nsc, "CET") . "\n";

		# process all trips with that NSC.
		@trips = ((grep { $_->{state}->{next_time} != $nsc } @trips), map {
			my $trip = $_;

			print STDERR "evaluating trip " . trip_details($trip) . "\n";

			# FIXME this will (very likely) break when a station is present on a route
			#       twice. this can happen (ring lines, drug overdose, ..)

			# XXX oh let's insert some sanity checks here.
			if (!defined($trip->{state}->{next_time})) {
				die("Trip " . trip_details($trip) . " -- has NO CURRENT TIME!");
			}
			if (!defined($trip->{state}->{station})) {
				die("Trip " . trip_details($trip) . " -- has NO CURRENT STATION!");
			}
			if (!($trip->{state}->{station} ~~ $physroute)) {
				die("Trip " . trip_details($trip) . " -- ended up off-route");
			}

			if ($trip->{state}->{state} eq "wait_arrive_station") {
				my $next_stop = (after { $_ eq $trip->{state}->{station} } @{$physroute})[0];
				print STDERR "what to do now at $trip->{state}->{station}...\n";

				# XXX here, ask the on-demand route generator.
				# find out all routes that:
				# 1) contain the current station
				# 2) contain the next station immediately after that in the route
				# 3) have their depart time after the current time
				my @poss_routes = map {
					my $route = $_;
					my $i_curr = firstidx { $_->{stop} eq $trip->{state}->{station} } @{$route->{route}};
					if ($i_curr == -1) { # cond 1
						()
					} elsif (!defined($route->{route}->[$i_curr + 1]) or $route->{route}->[$i_curr + 1]->{stop} ne $next_stop) { # cond 2
						();
					} elsif ($route->{route}->[$i_curr]->{depart} < $nsc) { # cond 3
						();
					} else {
						({
							route     => $route,
							route_pos => $i_curr,
							arrive    => $route->{route}->[$i_curr]->{arrive},
							depart    => $route->{route}->[$i_curr]->{depart},
						});
					}
				} @routes;

				print STDERR "* stay around and wait for one of these trains?\n";
				print STDERR "  - $_->{route}->{line} (arrives " . time2str("%H:%M", $_->{arrive}) . ")\n" foreach grep { $_->{arrive} > $nsc } @poss_routes;
				print STDERR "* enter one of these wonderful trains to get to $next_stop?\n";
				print STDERR "  - $_->{route}->{line} (departs " . time2str("%H:%M", $_->{depart}) . ")\n" foreach grep { $_->{arrive} <= $nsc } @poss_routes;

				# let's generate additional trips for the two possibilities.
				# note that the trip data is NOT deep cloned. this is intentional.
				my @rt;

				# if there are other trains that have not arrived yet, add trips for them.
				my $min_nsc = min map { $_->{arrive} } grep { $_->{arrive} > $nsc } @poss_routes;
				if (defined($min_nsc)) {
					push(@rt, {
						events => [ @{$trip->{events}} ],
						state => {
							station   => $trip->{state}->{station},
							next_time => $min_nsc,
							route     => undef,
							state     => "wait_arrive_station",
						},
					});
				}

				# add trips for all trains that have already arrived.
				foreach my $pr (grep { $_->{arrive} <= $nsc } @poss_routes) {
					push(@rt, {
						events => [ @{$trip->{events}}, {
							time    => $nsc,
							event   => "enter",
							station => $trip->{state}->{station},
							route   => $pr->{route},
						} ],
						state => {
							station   => $trip->{state}->{station},
							next_time => $pr->{depart},
							route     => $pr->{route},
							route_pos => $pr->{route_pos},
							state     => "wait_depart_train",
						},
					});
				}

				@rt;
			} elsif ($trip->{state}->{state} eq "wait_depart_train") {
				# flee with the train that has been entered.
				{
					events => [ @{$trip->{events}}, {
						time    => $nsc,
						event   => "depart",
						station => $trip->{state}->{station},
						route   => $trip->{state}->{route},
					} ],
					state => {
						station   => $trip->{state}->{station},
						next_time => $trip->{state}->{route}->{route}->[$trip->{state}->{route_pos} + 1]->{arrive},
						route     => $trip->{state}->{route},
						route_pos => $trip->{state}->{route_pos},
						state     => "wait_arrive_train",
					},
				};
			} elsif ($trip->{state}->{state} eq "wait_arrive_train") {
				# we arrived! generate trips for exiting trains and/or staying on train.
				# TODO only leave a train here if necessary, or determined to be
				#      an "attractive" choice, defined by some configuration parameter
				#      and the alternative trains available.
				#      (though trip overproduction can be defeated by not producing
				#      any trains to enter in the wait_arrive_station state)
				my @rt;

				# first add the arrive event to the event list and update state first.
				$trip->{state}->{route_pos}++;
				$trip->{state}->{station} = $trip->{state}->{route}->{route}->[$trip->{state}->{route_pos}]->{stop};
				push(@{$trip->{events}}, {
					time     => $nsc,
					event    => "arrive",
					station  => $trip->{state}->{station},
					route    => $trip->{state}->{route},
				});

				# if we arrived at the final stop, get off here and exit!
				if ($trip->{state}->{station} eq $physroute->[-1]) {
					push(@{$trip->{events}}, {
						time     => $nsc,
						event    => "exit",
						station  => $trip->{state}->{station},
						route    => $trip->{state}->{route},
					}, {
						time     => $nsc,
						event    => "vp_exit",
					});
					push(@completed_trips, $trip);
					();
				} else {
					# add trip for waiting in train, if the next stop is the next on route
					# FIXME check if it really is the NEXT on route FIXME
					if (defined($trip->{state}->{route}->{route}->[$trip->{state}->{route_pos} + 1])
					and $trip->{state}->{route}->{route}->[$trip->{state}->{route_pos} + 1]->{stop} ~~ $physroute) {
						push(@rt, {
							events => [ @{$trip->{events}} ],
							state => {
								station   => $trip->{state}->{station},
								next_time => $trip->{state}->{next_time},
								route     => $trip->{state}->{route},
								route_pos => $trip->{state}->{route_pos},
								state     => "wait_depart_train",
							},
						});
					}

					# get off at this station
					# TODO add "attractiveness" check as described above
					push(@rt, {
						events => [ @{$trip->{events}}, {
							time     => $nsc,
							event    => "exit",
							station  => $trip->{state}->{station},
							route    => $trip->{state}->{route},
						} ],
						state => {
							station   => $trip->{state}->{station},
							next_time => $nsc,
							route     => undef,
							route_pos => undef,
							state     => "wait_arrive_station",
						},
					}) ;# if (rand() < 0.1); # XXX XXX

					@rt;
				}
			} else {
				die("Trip has entered invalid or unknown state $trip->{state}->{state}");
			}
		} grep { $_->{state}->{next_time} == $nsc } @trips);

		print STDERR "Trips:\n";
		print STDERR "* " . trip_details($_) . "\n" foreach (@trips);
		print STDERR "\n";
	}

	# print result trips
	foreach my $trip (@completed_trips) {
		for (my $si = 0; $si < @{$trip->{events}}; $si++) {
			if ($trip->{events}->[$si]->{event} eq "enter") {
				warn("Next event not DEPART, bullshit ahead") if ($trip->{events}->[$si+1]->{event} ne "depart");
				print "\n";
				printf("%5s %2s  %-30s  %s\n",
					time2str("%H:%M", $trip->{events}->[$si+1]->{time}, "CET"),
					"ab",
					$trip->{events}->[$si]->{station},
					$trip->{events}->[$si]->{route}->{line},
				);
			} elsif ($trip->{events}->[$si]->{event} eq "exit") {
				warn("Previous event not ARRIVE, bullshit ahead") if ($trip->{events}->[$si-1]->{event} ne "arrive");
				printf("%5s %2s  %-30s\n",
					time2str("%H:%M", $trip->{events}->[$si-1]->{time}, "CET"),
					"an", $trip->{events}->[$si-1]->{station}
				);
			}
		}
		print "\n" . "-" x 40 . "\n";
#		<STDIN>;
	}
}

