#!/usr/bin/perl
use strict;
use warnings;
use 5.010;
use Data::Dumper;
use Graph;

$| = 1;

#use utf8;
#use encoding 'utf8';

# DATA
our %lines;
do("data/master");

# END DATA

# make the graph
print STDERR "Building graph";
my $g = new Graph;
while (my ($line, $linedata) = each(%lines))
{
	for (my $c = 0; $c < scalar(@{$linedata->{stops}}) - 2; $c += 2)
	{
		$g->add_weighted_edge(
			$linedata->{stops}->[$c+0]->{city} . " " . $linedata->{stops}->[$c+0]->{name},
			$linedata->{stops}->[$c+2]->{city} . " " . $linedata->{stops}->[$c+2]->{name},
			$linedata->{stops}->[$c+1]
		);
	}
}
print STDERR " - done (". scalar($g->vertices) . " vertices).\n";
my @way = $g->SP_Dijkstra("$ARGV[0] $ARGV[1]", "$ARGV[2] $ARGV[3]");
print STDERR "Found a way!\n";

print STDERR Dumper(@way);


__END__

sub print_connections
{
	foreach my $connection (@_) {
		my $skipped = 0;
		foreach my $stop (@{$connection}) {
			if ($stop->{name} ~~ @{[
			"Fasanenstraße", "Walsum Betriebshof", "Walsum Rathaus", "Sonnenstraße", "Schwan", "Striepweg",
			"Heckmann", "Wolfstraße", "Marxloh Pollmann", "Rhein-Ruhr-Halle", "Hamborn Rathaus", "Hamborn Feuerwache",
			"Amsterdamer Straße", "Theodor-Heuss-Straße", "Landschaftspark Nord", "Voßstraße", "Emilstraße",
			"Meiderich Bahnhof", "Auf dem Damm", "Duissern"]}) {
				$skipped++;
			} else {
				if ($skipped) {
					print "($skipped skipped)\n";
					$skipped = 0;
				}
				printf("%-20s %-40s %-10s\n",
					$stop->{city},
					$stop->{name},
					$stop->{line}
				);
			}
		}
		print "($skipped skipped)\n" if ($skipped);
		print "\n";
	}
	printf "(%d connections)\n", scalar(@_);
}

# find lines that stop at a station given by name and city.
sub find_lines_by_stop
{
	my ($city, $name) = @_;
	my @ret;
	
	print STDERR "{find_lines_by_stop $city $name}\n";
	foreach my $line (keys(%lines)) {
		if (grep { $_->{city} eq $city and $_->{name} eq $name } @{$lines{$line}->{stops}}) {
			print STDERR "{find_lines_by_stop $city $name R $line}\n";
			push(@ret, $line);
		}
	}
	
	return @ret;
}

# decompose a line identifier
sub decompose_line_name
{
	my ($scope, $name, $city, $end) = split(/:/, shift);
	return {
		scope => $scope, line => $name,
		city_to => $city, name_to => $end
	};
}

# find target lines based on current line, current stop, and lines used so far.
sub find_lines_from_stop
{
	my ($stop_last, @lines_used) = @_;
	
	my $line = decompose_line_name($stop_last->{line});
	
	# find lines that *could* continue from this stop
	my @lines_possible = find_lines_by_stop($stop_last->{city}, $stop_last->{name});
	my @lines_allowed;
	
	# should we be at the last station, the lines going further
	if (0 and $line->{city_to} eq $stop_last->{city}
	and $line->{name_to} eq $stop_last->{name}) {
		# xxx really add the lines going FURTHER, not all same-named
		push(@lines_allowed, grep {
			my $l = decompose_line_name($_);
			if ($l->{scope} eq $line->{scope}
			and $l->{name}  eq $line->{name}) {
				$_;
			} else {
				();
			}
		} @lines_possible);
	}
	
	# however, we exclude every line that has been used so far...
	@lines_allowed = grep {
		my $l = decompose_line_name($_);
		my $ret = 1;
		foreach my $u (@lines_used) {
			my $U = decompose_line_name($u);
			$ret = 0 if (
				$U->{scope} eq $l->{scope} and
				$U->{line}  eq $l->{line}
			);
		}
		$ret;
	} (@lines_possible, @lines_allowed);
	
	# ... except the one we're currently using
	push(@lines_allowed, $stop_last->{line});
	
	return @lines_allowed;
}

# take one incomplete connection and find new incomplete connections that
# approach the given target further
sub find_way_next_stop
{
	my ($city_to, $name_to, $connection) = @_;
	
	## print "I'm instructed to complete this connection to $city_to / $name_to:\n";
	## print Dumper($connection);
	
	# find lines that have been used so far
	my @lines_used = map { $_->{line} } @{$connection};
	
	# last stop is...
	my $stop_last = $connection->[scalar(@{$connection}) - 1];
	
	# now for every allowed line, find the current stop and append the next.
	return map {
		my @ret;
		for (my $c = 0; $c < scalar(@{$lines{$_}->{stops}}); $c++) {
			my $stop = $lines{$_}->{stops}->[$c];
			if ($stop->{city} eq $stop_last->{city}
			and $stop->{name} eq $stop_last->{name}) {
				my $stop_next = $lines{$_}->{stops}->[$c + 1];
				if ($stop_next) {
					push(@ret, [ @{$connection}, {
						city => $stop_next->{city},
						name => $stop_next->{name},
						line => $_
					} ]);
				}
			}
		}
		@ret;
	} find_lines_from_stop($stop_last, @lines_used);
}

sub find_way
{
	my ($city_from, $name_from, $city_to, $name_to) = @_;
	my @connections_finished; # complete connections
	my @connections_search;   # incomplete connections
	
	# find lines that have a stop at the start point, to generate initial
	# nodes
	foreach my $line (find_lines_by_stop($city_from, $name_from)) {
		push(@connections_search, [{
			city => $city_from,
			name => $name_from,
			
			line => $line
		}]);
	}
	
	while (scalar(@connections_search)) {
		# now find next stops
		my @cs_tmp;
		foreach my $connection (@connections_search) {
			push(@cs_tmp, find_way_next_stop($city_to, $name_to, $connection));
		}
		
		# remove completed ones
		push(@connections_finished, grep {
			my $stop_last = $_->[scalar(@{$_}) - 1];
				    $city_to eq $stop_last->{city}
				and $name_to eq $stop_last->{name}
		} @cs_tmp);
		
		# add them to the search list
		@connections_search = grep {
			my $stop_last = $_->[scalar(@{$_}) - 1];
			not(
				    $city_to eq $stop_last->{city}
				and $name_to eq $stop_last->{name}
			);
		} @cs_tmp;
		
		print "FINISHED CONNECTIONS:\n";
		print_connections(@connections_finished);
		print "CONNECTIONS IN PROGRESS:\n";
		print_connections(@connections_search);
		print "Iteration done. Press return to go on.\n"; <STDIN>;
	}
	
	print "\n\n\nCONNECTIONS FOUND:\n";
	print_connections(@connections_finished);
	
	return;
}

print Dumper(find_way(@ARGV));
